{"name":"Cluster2","body":"## What is cluster2\r\n\r\n![Travis status](https://secure.travis-ci.org/ql-io/cluster2.png)\r\n\r\ncluster2 is a node.js (>= 0.6.x) compatible multi-process management module. This module grew out of\r\nour needs in operationalizing node.js for [ql.io](https://github.com/ql-io/ql.io) at eBay. Built on\r\nnode's `cluster`, cluster2 adds several safeguards and utility functions to help support real-world\r\nproduction scenarios:\r\n\r\n* Scriptable start, shutdown and stop flows\r\n* Worker monitoring for process deaths\r\n* Worker recycling\r\n* Graceful shutdown\r\n* Idle timeouts\r\n* Validation hooks (for other tools to monitor cluster2 apps)\r\n* Events for logging cluster activities\r\n* and more coming soon\r\n\r\n## Usage\r\n\r\n### Getting cluster2\r\n\r\n    npm install cluster2\r\n\r\n### Start a TCP Server\r\n\r\n    var Cluster = require('cluster2'),\r\n        net = require('net');\r\n    var server = net.createServer(function (c) {\r\n        c.on('end', function () {\r\n            console.log('server disconnected');\r\n        });\r\n        c.write('hello\\r\\n');\r\n        c.pipe(c);\r\n    });\r\n\r\n    var c = new Cluster({\r\n        port: 3000,\r\n        cluster: true\r\n    });\r\n\r\n### Start a HTTP Server\r\n\r\n    var Cluster = require('cluster2'),\r\n        http = require('http');\r\n    var server = http.createServer(function (req, res) {\r\n        res.writeHead(200);\r\n        res.end('hello');\r\n    });\r\n    var c = new Cluster({\r\n        port: 3000\r\n    });\r\n    c.listen(function(cb) {\r\n        cb(server);\r\n    });\r\n\r\n### Start an Express Server\r\n\r\n    var Cluster = require('cluster2'),\r\n        express = require('express');\r\n    var app = express.createServer();\r\n    app.get('/', function(req, res) {\r\n        res.send('hello');\r\n    });\r\n\r\n    var c = new Cluster({\r\n        port: 3000,\r\n    });\r\n    c.listen(function(cb) {\r\n        cb(app);\r\n    });\r\n\r\n### Stop a Server\r\n\r\n    var Cluster = require('cluster2');\r\n    var c = new Cluster();\r\n    c.stop();\r\n\r\n### Gracefully Shutdown a Server\r\n\r\n    var Cluster = require('cluster2');\r\n    var c = new Cluster();\r\n    c.shutdown();\r\n\r\n\r\n## Options\r\n\r\nCluster2 takes the following options.\r\n\r\n* `cluster`: When `true` starts a number of workers. Use `false` to start the server as a single\r\n   process. Defaults to `true`.\r\n* `pids`: A directory to write PID files for master and workers.\r\n* `port`: Port number for the app, defaults to `3000`.\r\n* `monPort`: Port number for the monitor URL, defaults to `3001`. Go to `http://<localhost>:3001` to\r\n   view application logs (whatever is written to a `/logs` dir), and npm dependencies.\r\n* `ecv`: A validator to validate the runtime health of the app. If found unhealthy, emits a disable\r\n   traffic signal at path `/ecv`. ECV stands for \"extended content verification\".\r\n* `noWorkers`: Defaults to `os.cpus().length`.\r\n* `timeout`: Idle socket timeout. Automatically ends incoming sockets if found idle for this\r\n   duration. Defaults to `30` seconds.\r\n* `connThreshold`: When the number of connections processed exceeds this numbers, recycle the worker\r\n   process. This can help recover from slow leaks in your code or dependent modules.\r\n\r\n## Graceful Shutdown\r\n\r\nThe purpose of `shutdown()` is to let the server reject taking new connections, handle all pending\r\nrequests and end the connecton so that no request dropped. In order to handling `shutdown()`, the\r\nserver must handle `close` events as follows.\r\n\r\n    var serving = true;\r\n    var server = http.createServer(function (req, res) {\r\n        if(!serving) {\r\n            // Be nice and send a connection: close as otherwise the client may pump more requests\r\n            // on the same connection\r\n            res.writeHead(200, {\r\n                'connection': 'close'\r\n            });\r\n        }\r\n        res.writeHead(200);\r\n        res.end('hello');\r\n    });\r\n    server.on('close', function() {\r\n        serving = false;\r\n    })\r\n    var c = new Cluster({\r\n        port: 3000,\r\n        cluster: true\r\n    });\r\n\r\nCompletion of `shutdown()` does not necessarily mean that all worker processes are dead immediately. \r\nThe workers may take a while to complete processing of current requests and exit. The `shutdown()` \r\nflow only guarantees that the server takes no new connections.\r\n\r\n## Cluster2 Events\r\n\r\nCluster2 is an `EventEmitter` and emits the following events.\r\n\r\n* `died`: Emitted when a worker dies. This event is also emitted during normal `shutdown()` or\r\n  `stop()`.\r\n* `forked`: Emitted when a new worker is forked.\r\n* `<signal>`: Emitted when a worker receives a signal (such as `SIGKILL`, `SIGTERM` or `SIGINT`).\r\n\r\nHere is an example that logs these events to the disk.\r\n\r\n    var Cluster = require('cluster2'),\r\n        http = require('http');\r\n\r\n    var server = http.createServer(function (req, res) {\r\n        res.writeHead(200);\r\n        res.end('hello');\r\n    });\r\n    var c = new Cluster({\r\n        cluster: true,\r\n        port: 3000\r\n    });\r\n    c.on('died', function(pid) {\r\n        console.log('Worker ' + pid + ' died');\r\n    });\r\n    c.on('forked', function(pid) {\r\n        console.log('Worker ' + pid + ' forked');\r\n    });\r\n    c.on('SIGKILL', function() {\r\n        console.log('Got SIGKILL');\r\n    });\r\n    c.on('SIGTERM', function(event) {\r\n        console.log('Got SIGTERM - shutting down');\r\n    });\r\n    c.on('SIGINT', function() {\r\n        console.log('Got SIGINT');\r\n    });\r\n    c.listen(function(cb) {\r\n        cb(server);\r\n    });\r\n\r\n","tagline":"node.js cluster","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}